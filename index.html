<!doctype html>
<html lang="en">
  <head>
    <meta charset=utf-8>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Are we animated yet?</title>
  </head>
  <body role="document">

    <div class="container">
      <h1>Are we animated yet?</h1>
      <p>This page tracks the progress of implementing the <a
      href="http://w3c.github.io/web-animations/">Web Animations API</a>
      in Firefox. The status here refers to the status in the latest <a
      href="https://nightly.mozilla.org/">Firefox Nightly build</a>.
      In Firefox Developer Edition (aka Aurora) you'll see bits and pieces of
      the API, and in beta and release versions you'll see nothing at all
      unless you set <code>dom.animations-api.core.enabled</code> to true.</p>
      <p><a class="btn btn-primary btn-lg"
        href="https://nightly.mozilla.org/" role="button">Firefox
        Nightly &raquo;</a></p>
    </div>
    <div class="container" id="interfaces"></div>
  </body>
  <script src="js/vendor/react.js"></script>
  <script src="js/vendor/JSXTransformer.js"></script>
  <script src="js/vendor/zepto.min.js"></script>
  <script type="text/jsx">
    var BugTracker = function() {
      var pendingBugs = [];
      var loadedBugs = [];

      return {
        fetch: function() {
          var ids = Object.keys(pendingBugs).map(Number).join(',');
          var query = 'https://bugzilla.mozilla.org/rest/bug?id=' + ids
                      + '&include_fields=id,summary,status,resolution'
                      + ',last_change_time';
          var xhr = $.getJSON(query);
          var self = this;

          xhr.then(function(response) {

            response.bugs.forEach(function(bug) {
              loadedBugs[bug.id] = bug;
              if (pendingBugs.hasOwnProperty(bug.id)) {
                pendingBugs[bug.id].forEach(function(deferred) {
                  deferred.resolve(bug);
                });
                delete pendingBugs[bug.id];
              }
            });

            for(id in pendingBugs) {
              pendingBugs[id].forEach(function(deferred) {
                deferred.reject('Bug not found');
              });
            }
            pendingBugs = [];
          }).fail(function(xhr, error) {
            for(id in pendingBugs) {
              pendingBugs[id].forEach(function(deferred) {
                deferred.reject(error);
              });
            }
          });

          return xhr;
        },

        getBug: function(id) {
          var deferred = $.Deferred();
          if (loadedBugs.hasOwnProperty(id)) {
            deferred.resolve(loadedBugs[id]);
          } else {
            if (pendingBugs.hasOwnProperty(id)) {
              pendingBugs[id].push(deferred);
            } else {
              pendingBugs[id] = [ deferred ];
            }
          }
          return deferred.promise();
        }
      };
    };
    var bugTracker = new BugTracker();

    var InterfaceBox = React.createClass({
      render: function() {
        var specLink =
          'http://w3c.github.io/web-animations/#'
          + this.props.name.toLowerCase();
        return (
          <div className="interface">
            <span className="interface-name"><a
              href={specLink}>{this.props.name}</a></span>
            {
              this.props.members.map(function(member) {
                return <Member key={member.name} {...member} />;
              })
            }
          </div>
        );
      }
    });

    var Member = React.createClass({
      render: function() {
        var specLink =
          [ 'http://w3c.github.io/web-animations/#dom',
            this.props.interface.toLowerCase(),
            this.props.name.toLowerCase() ].join('-');
        return (
          <div className={'member ' + this.props.status}><a
            href={specLink}>{this.props.name}</a>
            {
              this.props.bugs.map(function(bugNum) {
                return <Bug key={'bug-' + bugNum} id={bugNum}
                            member={this.props.name} />;
              }.bind(this))
            }
          </div>
        );
      }
    });

    var Bug = React.createClass({
      getInitialState: function() {
        return { loadState: 'loading' };
      },
      getLoadEventName: function() {
        return 'bugs-loaded.' + this.props.member + '.' + this.props.id;
      },
      componentDidMount: function() {
        bugTracker.getBug(this.props.id).then(function(bug) {
          console.log(bug);
        }).fail(function(reason) {
          console.warn('Failed to fetch info for bug ' + this.props.id
                       + ' (reason: ' + reason + ')');
        }.bind(this));
      },
      componentWillUnmount: function() {
        $(document.body).off(this.getLoadEventName());
      },
      render: function() {
        var bugLink =
          'https://bugzilla.mozilla.org/show_bug.cgi?id=' + this.props.id;
        return (<span className={'bug ' + this.state.loadState}><a
          href={bugLink}>{this.props.id}</a></span>);
      }
    });

    $.getJSON('status.json').then(function(objects) {
      var renderObject = function(object) {
        // Massage members array into something nicer
        var members = Object.keys(object.members).map(function(name) {
          var result = object.members[name];
          result.name = name;
          result.interface = object.name;
          return result;
        });

        return <InterfaceBox name={object.name} members={members} />;
      };

      objects.forEach(function(object) {
        React.render(renderObject(object),
                     document.getElementById('interfaces'));
      });

      return bugTracker.fetch();
    }).fail(function(xhr, error) {
      $(document.body).append('Failed to load status.json: ' + error);
    });
  </script>
</html>
